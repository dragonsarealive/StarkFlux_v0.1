# Cursor Rules for Starknet Dev-Components Marketplace

## UI Contract Integration Pattern

For implementing the UI contract interaction layer, follow this structured approach:

1. **Layered Architecture**:
   * **Contract ABIs** (`src/abis/`): Define contract addresses and ABIs
   * **Mock Data** (`src/mocks/`): Create mock implementations for testing
   * **Hooks** (`src/hooks/`): Implement React hooks for contract interaction
   * **Utilities** (`src/utils/`): Add helper functions for data formatting
   * **Components** (`src/components/`): Build UI components using hooks
   * **Pages** (`src/pages/`): Compose page layouts with components

2. **Hook Implementation Strategy**:
   * Start with mock implementations for rapid UI development
   * Use consistent interfaces that will work with real contracts later
   * Include loading and error states in all hooks
   * Implement proper TypeScript types matching contract structures
   * Create composite hooks that combine data from multiple sources

3. **Contract Data Formatting**:
   * Use dedicated utility functions for all contract data formatting
   * Convert wei values to readable STRK amounts with proper decimals
   * Format timestamps to readable dates
   * Map numeric flags to human-readable strings
   * Create consistent formatting across all UI components

4. **Access Verification Pattern**:
   * Combine data from multiple contracts for access determination
   * Use a composite hook (useAccessVerification) that checks:
     - Direct purchase records
     - Marketplace subscription status
     - Developer subscription status
     - FREE component access
   * Return comprehensive access information for UI decisions

5. **React Component Implementation**:
   * Create reusable components for common contract entities
   * Handle loading, error, and empty states for all data fetching
   * Use consistent styling for contract-related UI elements
   * Implement proper type safety with TypeScript
   * Test components with various data scenarios

## Smart Contract Iterative Development Process

This process should be followed for developing smart contracts within this project to ensure stability and catch errors early.

1.  **Initial Contract Setup & Compile:**
    *   Define the basic contract module structure (e.g., `mod MyContract { ... }`).
    *   Include an empty `#[storage] struct Storage {}`.
    *   Include a minimal `#[constructor] fn constructor(ref self: ContractState) {}`.
    *   If it's a new contract target, add the relevant entry to `Scarb.toml` (e.g., in `[[target.starknet-contract]]`). Ensure it points to the correct source file (typically `src/contract_name.cairo` for named targets or `src/lib.cairo` for the default unnamed target).
    *   **Action:** Run `scarb build`. Fix any `Scarb.toml` or basic syntax issues.

2.  **Define Core Storage, Structs, Events & Compile:**
    *   Based on the contract's requirements (from `projectbrief.md`, `systemPatterns.md`), define all necessary storage variables within the `Storage` struct.
    *   Define any custom data structures (`structs`) that will be stored or used in function signatures/events. Add `#[derive(Drop, Serde, starknet::Store)]` as needed for stored structs. If structs are shared between contract targets or library modules, define them in a dedicated file (e.g., `src/types.cairo`) and import using `crate::types::MyStruct`.
    *   Define the main `#[starknet::event] enum Event { ... }` and the individual event structs `#[derive(Drop, starknet::Event)] struct MyEvent { ... }`.
    *   Add all necessary `use` statements for types like `ContractAddress`, `LegacyMap`, `u256` (from `core::integer::u256`), `get_block_timestamp`, etc.
    *   **Action:** Run `scarb build`. Fix any syntax, type, or import errors.

3.  **Implement Constructor & Compile:**
    *   Flesh out the `constructor` function.
    *   It should take parameters as required by the project specifications.
    *   Initialize all relevant storage variables.
    *   Include basic input validation using `assert`.
    *   For error messages in `Result::Err('message')` or `assert(condition, 'message')`, ensure 'message' is <= 31 characters to fit in `felt252`.
    *   **Action:** Run `scarb build`. Fix any logic or syntax errors in the constructor.

4.  **Define Interfaces (Preliminary) & Compile:**
    *   If the contract needs to call functions on other contracts (e.g., an ERC20 token, an oracle, another custom contract), define the necessary `#[starknet::interface] trait IMyInterface<TContractState> { ... }`.
    *   Initially, these interface traits can be defined directly within the current contract's file for simplicity during early development. They will be moved to a shared `src/interfaces.cairo` later.
    *   Add any new `use` statements required by the interface definitions (e.g., `u256`).
    *   **Action:** Run `scarb build`. Ensure interface syntax is correct.

5.  **Iterative Function Implementation & Compile Loop (Core Logic):**
    *   For each major function or logical group of related functions (e.g., `register_X`, `purchase_Y`, `update_Z_setting`, view functions, internal helpers):
        *   Implement the function signature and body within the `#[abi(embed_v0)] impl MyContractImpl of MyContract::MyContract<ContractState> { ... }` block.
        *   Add any internal helper functions (e.g., `_only_owner`, `_calculate_price`) as needed. These are typically not part of the ABI.
        *   Ensure functions correctly read from and write to storage.
        *   Use `get_caller_address()` for access control or to identify msg.sender.
        *   Emit events using `self.emit(Event::MyEvent(MyEvent { ... }));`.
        *   For external calls, create a dispatcher `let dispatcher = IMyInterfaceDispatcher { contract_address: address_from_storage };` and call its methods.
        *   Add comprehensive `assert` statements for input validation, state checks, and security (error messages <= 31 chars).
        *   For arithmetic operations that can overflow/underflow (especially `u256`), use the overflowing trait methods from `core::num::traits` (e.g., `a.overflowing_add(b)`) and handle the `(result, bool_overflow)` tuple, typically by returning a `Result<T, felt252>`.
        *   **Action:** Run `scarb build` *after implementing each significant function or small group of related functions.*
        *   **If compilation fails:** Diagnose the error message. Fix the syntax, logic, type mismatch, import error, etc.
        *   **Re-compile:** Run `scarb build` again. Repeat until the compilation for that function/set of functions is successful.
    *   Continue this sub-loop until all core functionalities specified in the project brief for the current smart contract are implemented.

6.  **Post-Core Logic Refactoring & Compile:**
    *   Once the entire core logic of the current smart contract is implemented and all functions compile successfully together:
        *   Move the in-file interface trait definitions to a dedicated `src/interfaces.cairo` file. This module should be declared in `src/lib.cairo`.
        *   Update the current contract to `use` the interfaces from `crate::interfaces::IMyInterface;` (or the appropriate path like `super::interfaces::...` if the contract itself is a module under `lib.cairo`).
        *   Create any necessary dispatcher imports (e.g., `use crate::interfaces::IMyInterfaceDispatcher;`).
        *   Identify any reusable utility functions. Plan to move these to a shared utility module (e.g., `src/math_utils.cairo`, declared in `src/lib.cairo`).
        *   Review the contract for clarity, consistency in error messages, and any obvious gross inefficiencies.
        *   **Action:** Run `scarb build` after each significant refactoring step.

This iterative process helps manage complexity, catches errors when they are easiest to fix, and ensures a constantly working (compilable) state of the smart contract during development.

## Cairo Development Notes & Patterns

*   **`u256` Import:** Always use `use core::integer::u256;`.
*   **Shared Types (Structs/Enums):** If a type is used by multiple contracts or library modules, define it in a central file (e.g., `src/types.cairo`, declared as a module in `src/lib.cairo`). Import using `crate::types::MyType` from other modules/contracts in the same Scarb package.
*   **Shared Interfaces:** Define in `src/interfaces.cairo` (module in `src/lib.cairo`). Import dispatchers and traits using `crate::interfaces::...`.
*   **Shared Library Code (e.g., Math Utilities):** Create modules like `src/math_utils.cairo` (declared in `src/lib.cairo`).
*   **Overflowing Arithmetic:** Use traits from `core::num::traits` (e.g., `a.overflowing_add(b)`). These return a `(result, bool_overflow)` tuple.
*   **Error Message Length:** String literals in `assert` or `Result::Err` must be 31 characters or less to fit in `felt252`.
*   **Scarb Target Paths:** For `[[target.starknet-contract]]` in `Scarb.toml`:
    *   An unnamed target defaults to `src/lib.cairo`.
    *   A named target (e.g., `name = "my_contract"`) defaults to `src/my_contract.cairo`.
    *   Avoid using `source-path` with named `starknet-contract` targets if issues arise; prefer the default pathing.
*   **`U128_MAX`:** Currently no standard named constant found easily. Manually define `const U128_MAX: u128 = 340282366920938463463374607431768211455;` if needed.
*   **Subscription Models:** The project now supports three monetization paths:
    *   **Direct Purchase:** One-time payment for component access
    *   **Marketplace Subscription:** Global subscription with shared access pool
    *   **Developer Subscription:** Subscribe to specific developer for all their content
*   **Fee Split Pattern:** Use the 45/45/10 (developer/platform/liquidity) split for subscription fees consistently across all subscription types.
*   **DateTime Handling:** For subscription/epoch expiry, use unix timestamps (seconds since epoch) with:
    *   `get_block_timestamp()` for current time
    *   For renewals, use `max(current_time, existing_expiry) + duration` pattern
*   **Access Control Pattern:** Use helper functions like `_only_owner()` and `_check_developer_owner()` to verify permissions.
*   **Event Emission:** Always emit events for state changes like subscriptions, price updates, etc.
*   **Oracle-Based USD Pricing Pattern:** For stable USD prices:
    *   Use `OraclePriceCfg` struct to store USD price and oracle feed key
    *   Implement `_usd_to_strk` helper function for price conversion
    *   Use `IPragmaOracleDispatcher` to fetch current price data
    *   Check for price staleness with `assert(now - last_updated_timestamp <= max_staleness, ErrOraclePriceStale)`
    *   Add fallback to fixed STRK pricing when Oracle config isn't set
    *   Implement separate setters for STRK and USD prices
    *   Always clear one price format when setting the other to avoid conflicts
    *   Add get_price_usd view function for UI display
    *   Use Oracle power-of-10 helper for common decimal values (6, 8, 10, 12)
*   **Interface Consistency Pattern:** For maintainable interfaces:
    *   Use consistent parameter types across all interfaces (e.g., component_id as u64)
    *   Keep symmetrical view functions in related contracts (e.g., get_price_usd in both subscription contracts)
    *   Follow standard interface structure (core, admin, view functions)
    *   Include sufficient data in events for indexers (e.g., access_flags in component events)
    *   Keep all interfaces in a single file without duplicates for clarity
*   **Utility Function Centralization Pattern:** For shared functionality:
    *   Centralize math operations in math_utils.cairo
    *   Provide conversion functions for different numeric types (uint256_from_felt252, u256_from_u128)
    *   Implement common power of 10 calculations once in shared utilities
    *   Use consistent utility function naming across the project