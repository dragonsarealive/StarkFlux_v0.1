// Version V1.1.0 - Sepolia Deployment
#[starknet::contract]
mod DevSubscription {
    use starknet::{ContractAddress, get_caller_address, get_block_timestamp};
    use starknet::storage::Map;
    use core::integer::u256;
    use core::traits::TryInto;
    use core::zeroable::Zeroable;
    use common::interfaces::{
        IERC20Dispatcher, IERC20DispatcherTrait,
        IUniversalIdentityRegistryDispatcher, IUniversalIdentityRegistryDispatcherTrait,
        IDevSubscription, IPragmaOracleDispatcher, IPragmaOracleDispatcherTrait,
        IComponentRegistryExternalDispatcher, IComponentRegistryExternalDispatcherTrait
    };
    use common::math_utils;
    use common::types::{OraclePriceCfg, AccessFlags};
    use common::math_utils::{u256_safe_mul, u256_safe_div, pow10_u256, uint256_div_u16, uint256_mul_u16, get_oracle_power_of_10};

    // Added in v1.1.0 - Contract version constant
    const CONTRACT_VERSION: felt252 = 'v1.1.0';

    // Fee constants
    const DEVELOPER_FEE_BPS: u16 = 8000; 
    const PLATFORM_FEE_BPS: u16 = 1000;
    const LIQUIDITY_FEE_BPS: u16 = 1000;
    const BASIS_POINT_DENOMINATOR: u16 = 10000;

    // Other constants
    const DEFAULT_SUBSCRIPTION_DURATION: u64 = 2592000; // 30 days in seconds

    // Error constants
    const ERR_ZERO_ADDRESS: felt252 = 'ERR_ZERO_ADDRESS';
    const ERR_OWNER_ONLY: felt252 = 'ERR_OWNER_ONLY';
    const ERR_DEV_ONLY: felt252 = 'ERR_DEV_ONLY';
    const ERR_PRICE_ZERO: felt252 = 'ERR_PRICE_ZERO';
    const ERR_IDENTITY_NOT_FOUND: felt252 = 'ERR_IDENTITY_NOT_FOUND';
    const ERR_INVALID_PRICE: felt252 = 'ERR_INVALID_PRICE';
    const ERR_TRANSFER_FAILED: felt252 = 'ERR_TRANSFER_FAILED';
    const ERR_NOT_ELIGIBLE: felt252 = 'ERR_NOT_ELIGIBLE';
    const ERR_COMPONENT_REGISTRY: felt252 = 'ERR_COMPONENT_REGISTRY';
    // Added in v1.1.0 - New error constant
    const ERR_INVALID_VERSION_V110: felt252 = 'ERR_INVALID_VERSION_V110';

    // Constants for Oracle and USD conversion
    const STRK_SCALING_FACTOR_U256: u256 = u256 { low: 1_000_000_000_000_000_000, high: 0 }; // 10^18
    const USD_MICROS_SCALING_FACTOR_U256: u256 = u256 { low: 1_000_000, high: 0 }; // 10^6
    
    // Zero address constant
    const ZERO_ADDRESS: ContractAddress = 0.try_into().unwrap();
    
    // Add oracle-related error constants
    const ErrOracleDataInvalid: felt252 = 'ERR_ORACLE_DATA_INVALID';
    const ErrClockError: felt252 = 'ERR_CLOCK_ERROR';
    const ErrOraclePriceStale: felt252 = 'ERR_ORACLE_PRICE_STALE';
    const ErrOraclePriceZero: felt252 = 'ERR_ORACLE_PRICE_ZERO';
    const ErrPriceTooLarge: felt252 = 'ERR_PRICE_TOO_LARGE';

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        Subscribed: Subscribed,
        PriceSet: PriceSet,
        PriceUsdSet: PriceUsdSet,
    }

    #[derive(Drop, starknet::Event)]
    struct Subscribed {
        #[key]
        user: ContractAddress,
        #[key]
        dev_id: u64,
        expiry: u64,
    }

    #[derive(Drop, starknet::Event)]
    struct PriceSet {
        #[key]
        dev_id: u64,
        price: u256,
    }

    #[derive(Drop, starknet::Event)]
    struct PriceUsdSet {
        #[key]
        dev_id: u64,
        price_usd_micros: u256,
        price_feed_key: felt252,
    }

    #[storage]
    struct Storage {
        subscription_expiry: Map<(u64, ContractAddress), u64>, // (devId, user) -> expiry timestamp
        dev_prices: Map<u64, u256>, // devId -> subscription price
        dev_price_cfg: Map<u64, OraclePriceCfg>, // devId -> oracle price config
        identity_registry: ContractAddress,
        platform_treasury: ContractAddress,
        liquidity_vault: ContractAddress,
        strk_token: ContractAddress,
        sub_duration_secs: u64, // 30 days in seconds (2,592,000)
        owner: ContractAddress,
        pragma_oracle_address: ContractAddress,
        oracle_max_staleness: u64,
        component_registry: ContractAddress, // Added component registry address
        // Added in v1.1.0 - Contract version
        version: felt252,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        identity_registry: ContractAddress,
        platform_treasury: ContractAddress,
        liquidity_vault: ContractAddress,
        strk_token: ContractAddress,
        pragma_oracle_address: ContractAddress,
        component_registry: ContractAddress // Added component registry parameter
    ) {
        // Validate inputs
        assert(identity_registry != ZERO_ADDRESS, ERR_ZERO_ADDRESS);
        assert(platform_treasury != ZERO_ADDRESS, ERR_ZERO_ADDRESS);
        assert(liquidity_vault != ZERO_ADDRESS, ERR_ZERO_ADDRESS);
        assert(strk_token != ZERO_ADDRESS, ERR_ZERO_ADDRESS);
        assert(pragma_oracle_address != ZERO_ADDRESS, ERR_ZERO_ADDRESS);
        assert(component_registry != ZERO_ADDRESS, ERR_ZERO_ADDRESS);

        // Set contract addresses
        self.identity_registry.write(identity_registry);
        self.platform_treasury.write(platform_treasury);
        self.liquidity_vault.write(liquidity_vault);
        self.strk_token.write(strk_token);
        self.pragma_oracle_address.write(pragma_oracle_address);
        self.component_registry.write(component_registry);

        // Set default subscription duration (30 days)
        self.sub_duration_secs.write(DEFAULT_SUBSCRIPTION_DURATION);
        
        // Set default oracle staleness (5 minutes)
        self.oracle_max_staleness.write(300);

        // Set owner to caller
        let caller = get_caller_address();
        self.owner.write(caller);
        
        // Added in v1.1.0 - Set version
        self.version.write(CONTRACT_VERSION);
    }

    // Helper functions for internal use within the contract
    #[generate_trait]
    impl DevSubscriptionInternalImpl of DevSubscriptionInternal {
        // Internal helper: Checks if caller is the developer
        fn _check_developer_owner(self: @ContractState, dev_id: u64, caller: ContractAddress) -> bool {
            let identity_registry = self.identity_registry.read();
            let identity_registry_dispatcher = IUniversalIdentityRegistryDispatcher {
                contract_address: identity_registry
            };
            
            // Get the developer's identity
            let identity = identity_registry_dispatcher.get_identity(dev_id);
            let developer_address = identity.owner;
            
            // Check if caller is the developer
            caller == developer_address
        }
        
        // Internal helper: Converts USD price to STRK using oracle data
        fn _usd_to_strk(self: @ContractState, cfg: OraclePriceCfg) -> u256 {
            // Use the centralized usd_to_strk function from math_utils
            math_utils::usd_to_strk(
                self.pragma_oracle_address.read(),
                cfg,
                self.oracle_max_staleness.read()
            )
        }

        // Internal helper: Calculates a fee share based on basis points
        fn _calculate_fee_share(total: u256, basis_points: u16) -> u256 {
            math_utils::uint256_div_u16(
                math_utils::uint256_mul_u16(total, basis_points),
                BASIS_POINT_DENOMINATOR
            )
        }
        
        // Internal helper: Handles subscription payment with 80/10/10 fee distribution
        fn _handle_subscription_payment(
            ref self: ContractState,
            dev_id: u64,
            subscriber: ContractAddress,
            total_price: u256
        ) {
            // Get developer address from identity registry
            let identity_registry = self.identity_registry.read();
            let identity_registry_dispatcher = IUniversalIdentityRegistryDispatcher {
                contract_address: identity_registry
            };
            let identity = identity_registry_dispatcher.get_identity(dev_id);
            let developer_address = identity.owner;
            
            // Get token addresses
            let platform_treasury = self.platform_treasury.read();
            let liquidity_vault = self.liquidity_vault.read();
            let strk_token = self.strk_token.read();
            
            // Create token dispatcher
            let token_dispatcher = IERC20Dispatcher { contract_address: strk_token };
            
            // First transfer the total amount from subscriber to the contract
            let contract_address = starknet::get_contract_address();
            let success_transfer = token_dispatcher.transfer_from(subscriber, contract_address, total_price);
            assert(success_transfer, ERR_TRANSFER_FAILED);
            
            // Calculate fee shares (80/10/10 split)
            let dev_fee = Self::_calculate_fee_share(total_price, DEVELOPER_FEE_BPS);       // 80%
            let platform_fee = Self::_calculate_fee_share(total_price, PLATFORM_FEE_BPS);   // 10%
            let liquidity_fee = Self::_calculate_fee_share(total_price, LIQUIDITY_FEE_BPS); // 10%
            
            // Verify split adds up to 100% (within rounding error)
            let total_distributed = dev_fee + platform_fee + liquidity_fee;
            assert(
                total_price >= total_distributed && 
                total_price - total_distributed <= u256 { low: 10, high: 0 }, // Allow for small rounding error
                'Fee split error'
            );
            
            // Distribute funds
            if !dev_fee.is_zero() {
                token_dispatcher.transfer(developer_address, dev_fee);
            }
            
            if !platform_fee.is_zero() {
                token_dispatcher.transfer(platform_treasury, platform_fee);
            }
            
            if !liquidity_fee.is_zero() {
                token_dispatcher.transfer(liquidity_vault, liquidity_fee);
            }
        }
    }

    #[abi(embed_v0)]
    impl DevSubscriptionImpl of common::interfaces::IDevSubscription<ContractState> {
        // External methods
        fn subscribe(ref self: ContractState, dev_id: u64) {
            let caller = get_caller_address();
            
            // Get the subscription price for this developer
            let price = self.get_price(dev_id);
            
            // Ensure price is set
            assert(!price.is_zero(), ERR_INVALID_PRICE);
            
            // Get identity to check for components
            let identity_registry = self.identity_registry.read();
            let identity_registry_dispatcher = IUniversalIdentityRegistryDispatcher {
                contract_address: identity_registry
            };
            
            let identity = identity_registry_dispatcher.get_identity(dev_id);
            let _developer_address = identity.owner;
            
            // Verify the developer has DEV_SUB eligible components
            let component_registry = self.component_registry.read();
            // We'll assume component validation happens in the UI/frontend
            // This is just a placeholder for future component validation
            let _component_registry_dispatcher = IComponentRegistryExternalDispatcher {
                contract_address: component_registry
            };
            
            // Check at least one component from this developer has the DEV_SUB flag
            // Note: In a real implementation, we'd need to iterate through all components 
            // from this developer to verify at least one has DEV_SUB flag.
            // For now, we'll assume this check happens in the UI/frontend and trust
            // that dev_id is valid and has eligible components.
            
            // Get current timestamp and existing subscription if any
            let current_time = get_block_timestamp();
            let existing_expiry = self.subscription_expiry.read((dev_id, caller));
            
            // Calculate new expiry (if already subscribed, extend from current expiry)
            let sub_duration = self.sub_duration_secs.read();
            let new_expiry = if existing_expiry > current_time {
                existing_expiry + sub_duration
            } else {
                current_time + sub_duration
            };
            
            // Update subscription expiry
            self.subscription_expiry.write((dev_id, caller), new_expiry);
            
            // Process payment with 80/10/10 fee distribution
            DevSubscriptionInternalImpl::_handle_subscription_payment(
                ref self, 
                dev_id,
                caller,
                price
            );
            
            // Emit subscription event
            self.emit(Event::Subscribed(Subscribed { 
                user: caller,
                dev_id,
                expiry: new_expiry
            }));
        }

        fn is_subscribed(self: @ContractState, user: ContractAddress, dev_id: u64) -> bool {
            // Get current timestamp and subscription expiry
            let current_time = get_block_timestamp();
            let expiry = self.subscription_expiry.read((dev_id, user));
            
            // Check if subscription is still active
            current_time <= expiry
        }

        fn set_price(ref self: ContractState, dev_id: u64, price: u256) {
            let caller = get_caller_address();
            
            // Check if caller is the owner of the contract or the developer
            let is_contract_owner = caller == self.owner.read();
            let is_developer_owner = DevSubscriptionInternalImpl::_check_developer_owner(@self, dev_id, caller);
            
            // Only allow the contract owner or the developer to set the price
            assert(is_contract_owner || is_developer_owner, ERR_DEV_ONLY);
            
            // Can't set price to zero
            assert(!price.is_zero(), ERR_PRICE_ZERO);
            
            // Clear USD price config to avoid conflicts between pricing models
            let empty_cfg = OraclePriceCfg {
                price_usd_micros: u256 { low: 0, high: 0 },
                price_feed_key: 0
            };
            self.dev_price_cfg.write(dev_id, empty_cfg);
            
            // Set the price
            self.dev_prices.write(dev_id, price);
            
            // Emit event
            self.emit(Event::PriceSet(PriceSet { dev_id, price }));
        }

        fn get_price(self: @ContractState, dev_id: u64) -> u256 {
            // Read the fixed STRK price
            let strk_price = self.dev_prices.read(dev_id);
            
            // If STRK price is set, return it
            if !strk_price.is_zero() {
                return strk_price;
            }
            
            // Otherwise, check if we have a USD price config
            let cfg = self.dev_price_cfg.read(dev_id);
            if !cfg.price_usd_micros.is_zero() {
                // Convert USD to STRK using oracle
                return DevSubscriptionInternalImpl::_usd_to_strk(self, cfg);
            }
            
            // No price is set
            u256 { low: 0, high: 0 }
        }

        fn get_subscription_expiry(self: @ContractState, user: ContractAddress, dev_id: u64) -> u64 {
            self.subscription_expiry.read((dev_id, user))
        }

        fn set_price_usd(ref self: ContractState, dev_id: u64, price_usd_micros: u256, price_feed_key: felt252) {
            let caller = get_caller_address();
            
            // Check if caller is the owner of the contract or the developer
            let is_contract_owner = caller == self.owner.read();
            let is_developer_owner = DevSubscriptionInternalImpl::_check_developer_owner(@self, dev_id, caller);
            
            // Only allow the contract owner or the developer to set the price
            assert(is_contract_owner || is_developer_owner, ERR_DEV_ONLY);
            
            // Can't set price to zero
            assert(!price_usd_micros.is_zero(), ERR_PRICE_ZERO);
            assert(price_feed_key != 0, 'ERR_PRICE_FEED_KEY_ZERO');
            
            // Store the USD price config
            let cfg = OraclePriceCfg {
                price_usd_micros: price_usd_micros,
                price_feed_key: price_feed_key
            };
            self.dev_price_cfg.write(dev_id, cfg);
            
            // Clear STRK price to avoid conflicts between pricing models
            self.dev_prices.write(dev_id, u256 { low: 0, high: 0 });
            
            // Emit event with USD price details
            self.emit(Event::PriceUsdSet(PriceUsdSet {
                dev_id,
                price_usd_micros,
                price_feed_key
            }));
            
            // Get a reference for oracle conversion
            let self_ref = @self;
            
            // Calculate current equivalent STRK price for the event
            let strk_price = DevSubscriptionInternalImpl::_usd_to_strk(self_ref, cfg);
            
            // Emit event with current STRK price equivalent 
            self.emit(Event::PriceSet(PriceSet { dev_id, price: strk_price }));
        }

        fn get_price_usd(self: @ContractState, dev_id: u64) -> u256 {
            let cfg = self.dev_price_cfg.read(dev_id);
            cfg.price_usd_micros
        }

        // Add the new function
        fn get_version(self: @ContractState) -> felt252 {
            self.version.read()
        }
    }
} 